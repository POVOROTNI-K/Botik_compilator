import os
import logging
import tempfile
import asyncio
import zipfile
import pypandoc
import subprocess
import shutil
import sys
import pytesseract
import win32api  # –î–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—É—Ç—è–º–∏ –≤ Windows
from pdf2image import convert_from_path
from PIL import Image
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    InputFile,
    ReplyKeyboardMarkup
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackContext,
    CallbackQueryHandler,
    filters,
    ContextTypes
)
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
TOKEN = "8029314491:AAFiFXIBkWPUaf8Up1zFkDpsRTNc5v9UiCg"
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ Tesseract
try:
    tesseract_path = shutil.which('tesseract')
    if tesseract_path:
        pytesseract.pytesseract.tesseract_cmd = tesseract_path
        logger.info(f"Tesseract –Ω–∞–π–¥–µ–Ω: {tesseract_path}")
    else:
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø—É—Ç–∏
        possible_paths = [
            '/opt/homebrew/bin/tesseract',    # macOS Apple Silicon
            '/usr/local/bin/tesseract',        # macOS Intel
            '/usr/bin/tesseract',              # Linux
            r'C:\Program Files\Tesseract-OCR\tesseract.exe'  # Windows
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                logger.info(f"–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Tesseract: {path}")
                break
        else:
            logger.warning("Tesseract –Ω–µ –Ω–∞–π–¥–µ–Ω! –§—É–Ω–∫—Ü–∏–∏ OCR –±—É–¥—É—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã")
except Exception as e:
    logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Tesseract: {str(e)}")

# ================== –§–£–ù–ö–¶–ò–ò –ö–û–ù–í–ï–†–¢–ê–¶–ò–ò PDF-LATEX ==================

def escape_latex(text):
    """–≠–∫—Ä–∞–Ω–∏—Ä—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è LaTeX."""
    temp_marker = '__!!BACKSLASH!!__'
    text = text.replace('\\', temp_marker)
    replacements = {
        '{': r'\{', '}': r'\}',
        '#': r'\#', '$': r'\$', '%': r'\%',
        '&': r'\&', '_': r'\_', '~': r'\textasciitilde{}',
        '^': r'\textasciicircum{}'
    }
    for char, escaped in replacements.items():
        text = text.replace(char, escaped)
    text = text.replace(temp_marker, r'\textbackslash{}')
    return text

def pdf_to_latex(pdf_path, output_tex_path, lang='rus+eng'):
    """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç PDF –≤ LaTeX —Å –ø–æ–º–æ—â—å—é OCR."""
    try:
        with tempfile.TemporaryDirectory() as temp_dir:
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º PDF –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            images = convert_from_path(pdf_path, output_folder=temp_dir)
            
            latex_content = [
                r"\documentclass{article}",
                r"\usepackage[T1,T2A]{fontenc}",
                r"\usepackage[utf8]{inputenc}",
                r"\usepackage[russian,english]{babel}",
                r"\usepackage{cmap}",
                r"\usepackage{textcomp}",
                r"\begin{document}"
            ]
            
            for i, image in enumerate(images):
                img_path = os.path.join(temp_dir, f"page_{i+1}.png")
                image.save(img_path, 'PNG')
                
                # –†–∞—Å–ø–æ–∑–Ω–∞—ë–º —Ç–µ–∫—Å—Ç
                text = pytesseract.image_to_string(
                    Image.open(img_path), 
                    lang=lang
                )
                escaped_text = escape_latex(text)
                latex_content.append(escaped_text)
                
                if i < len(images) - 1:
                    latex_content.append(r"\newpage")
            
            latex_content.append(r"\end{document}")
            
            with open(output_tex_path, 'w', encoding='utf-8') as f:
                f.write("\n".join(latex_content))
                
        return True
    except Exception as e:
        logger.error(f"PDF to LaTeX error: {str(e)}")
        return False

def latex_to_pdf(latex_file, pdf_file=None, clean_temp=True):
    """–ö–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç LaTeX –≤ PDF —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –ø—É—Ç–µ–π Windows."""
    try:
        # –°–æ–∑–¥–∞–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ –ø—É—Ç–∏
        latex_file = os.path.abspath(latex_file)
        work_dir = os.path.dirname(latex_file)
        base_name = os.path.splitext(os.path.basename(latex_file))[0]
        
        # –î–ª—è Windows: –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –∫–æ—Ä–æ—Ç–∫–∏–µ –ø—É—Ç–∏ (8.3)
        if sys.platform == 'win32':
            try:
                latex_file = win32api.GetShortPathName(latex_file)
                work_dir = win32api.GetShortPathName(work_dir)
                logger.info(f"Converted to short path: {latex_file}")
            except Exception as e:
                logger.warning(f"Short path conversion failed: {str(e)}")
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—ã—Ö–æ–¥–Ω–æ–π PDF
        if not pdf_file:
            pdf_file = os.path.join(work_dir, f"{base_name}.pdf")
        pdf_file = os.path.abspath(pdf_file)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É —Ñ–∞–π–ª–∞
        if os.path.exists(pdf_file):
            try:
                os.remove(pdf_file)
            except PermissionError:
                raise RuntimeError(f"PDF file is locked: {pdf_file}")
        
        # –ö–æ–º–ø–∏–ª–∏—Ä—É–µ–º —Å –ø–æ–º–æ—â—å—é pdflatex (2 –ø—Ä–æ—Ö–æ–¥–∞)
        compile_cmd = [
            "pdflatex",
            "-interaction=nonstopmode",
            "-halt-on-error",
            "-file-line-error",
            f"-output-directory={work_dir}",
            latex_file
        ]
        
        # –ü–µ—Ä–≤—ã–π –ø—Ä–æ—Ö–æ–¥
        result1 = subprocess.run(
            compile_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=work_dir
        )
        
        # –í—Ç–æ—Ä–æ–π –ø—Ä–æ—Ö–æ–¥
        result2 = subprocess.run(
            compile_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=work_dir
        )
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        final_pdf = os.path.join(work_dir, f"{base_name}.pdf")
        if not os.path.exists(final_pdf):
            error_msg = "\n".join([
                "LaTeX compilation error:",
                "=== FIRST PASS ===",
                result1.stdout[:1000],
                result1.stderr[:1000],
                "=== SECOND PASS ===",
                result2.stdout[:1000],
                result2.stderr[:1000]
            ])
            raise RuntimeError(error_msg)
        
        # –ü–µ—Ä–µ–º–µ—â–∞–µ–º –∏—Ç–æ–≥–æ–≤—ã–π PDF
        shutil.move(final_pdf, pdf_file)
        logger.info(f"PDF compiled: {pdf_file}")
        
        # –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
        if clean_temp:
            temp_extensions = ['.aux', '.log', '.out', '.toc', '.lof', '.lot']
            for ext in temp_extensions:
                temp_file = os.path.join(work_dir, f"{base_name}{ext}")
                if os.path.exists(temp_file):
                    os.remove(temp_file)
            logger.info("Temporary files cleaned")
            
        return True
    except Exception as e:
        logger.error(f"LaTeX to PDF error: {str(e)}")
        return False

# ================== –¢–ï–õ–ï–ì–†–ê–ú –ë–û–¢ ==================

# –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
def main_menu_keyboard():
    return ReplyKeyboardMarkup([
        ["üìÑ –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏ ", "‚ÑπÔ∏è –ü–æ–º–æ—â—å"],
        ["üîÑ –≠—Ö–æ-—Ä–µ–∂–∏–º", "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏"]
    ], resize_keyboard=True)

# –ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
def conversion_menu_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("DOCX ‚û° LaTeX", callback_data="docx_to_tex"),
         InlineKeyboardButton("LaTeX ‚û° DOCX", callback_data="tex_to_docx")],
        [InlineKeyboardButton("PDF ‚û° LaTeX", callback_data="pdf_to_tex"),
         InlineKeyboardButton("LaTeX ‚û° PDF", callback_data="tex_to_pdf")]
    ])

async def start(update: Update, context: CallbackContext):
    user = update.effective_user
    await update.message.reply_text(
        f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! 
–Ø –±–æ—Ç –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏  —Ñ–∞–π–ª–æ–≤ –≤ LaTeX. –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Ñ–∞–π–ª, —Ç—Ä–µ–±—É—é—â–∏–π –æ–±—Ä–∞–±–æ—Ç–∫–∏, –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É \help, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –ø—Ä–æ –æ—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã.",
        reply_markup=main_menu_keyboard()
    )

async def help_command(update: Update, context: CallbackContext):
    help_text = (
        "üìå –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏:\n"
        "‚Ä¢ üìÑ –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏ - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤\n"
        "‚Ä¢ ‚ÑπÔ∏è –ü–æ–º–æ—â—å - —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ\n"
        "‚Ä¢ üîÑ –≠—Ö–æ-—Ä–µ–∂–∏–º - –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ –≤–∞—à–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π\n"
        "‚Ä¢ ‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ - –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±–æ—Ç–∞\n\n"
        "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏:\n"
        "‚ñ∏ DOCX ‚áÑ LaTeX\n"
        "‚ñ∏ PDF ‚áÑ LaTeX\n"
        "‚ñ∏ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤\n\n"
        "–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏!"
    )
    await update.message.reply_text(help_text)

async def button_handler(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()
    
    conversion_types = {
        "docx_to_tex": "üì§ –û—Ç–ø—Ä–∞–≤—å—Ç–µ DOCX —Ñ–∞–π–ª –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –≤ LaTeX",
        "tex_to_docx": "üì§ –û—Ç–ø—Ä–∞–≤—å—Ç–µ LaTeX —Ñ–∞–π–ª (.tex) –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –≤ DOCX",
        "pdf_to_tex": "üì§ –û—Ç–ø—Ä–∞–≤—å—Ç–µ PDF —Ñ–∞–π–ª –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –≤ LaTeX",
        "tex_to_pdf": "üì§ –û—Ç–ø—Ä–∞–≤—å—Ç–µ LaTeX —Ñ–∞–π–ª (.tex) –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –≤ PDF"
    }
    
    if query.data in conversion_types:
        context.user_data['conversion'] = query.data
        await query.edit_message_text(conversion_types[query.data])

async def handle_text(update: Update, context: CallbackContext):
    text = update.message.text
    
    if text == "üìÑ –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏":
        await update.message.reply_text(
            "üîß –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏:",
            reply_markup=conversion_menu_keyboard()
        )
    elif text == "‚ÑπÔ∏è –ü–æ–º–æ—â—å":
        await help_command(update, context)
    elif text == "üîÑ –≠—Ö–æ-—Ä–µ–∂–∏–º":
        context.user_data['echo'] = True
        await update.message.reply_text("–≠—Ö–æ-—Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω üîÑ")
    elif text == "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏":
        await update.message.reply_text("‚öôÔ∏è –¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:\n- –§–æ—Ä–º–∞—Ç –ª–æ–≥–æ–≤: TEXT\n- –ö–æ–¥–∏—Ä–æ–≤–∫–∞: UTF-8")
    else:
        if context.user_data.get('echo'):
            await update.message.reply_text(f"üîÅ –≠—Ö–æ: {text}")

async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE):
    doc = update.message.document
    user = update.effective_user
    file_ext = os.path.splitext(doc.file_name)[1].lower() if doc.file_name else ''
    conversion_type = context.user_data.get('conversion')

    try:
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
        handlers = {
            "docx_to_tex": process_docx_to_tex,
            "tex_to_docx": process_tex_to_docx,
            "pdf_to_tex": process_pdf_to_tex,
            "tex_to_pdf": process_tex_to_pdf
        }
        
        # –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é
        if not conversion_type:
            if file_ext == '.docx':
                conversion_type = "docx_to_tex"
            elif file_ext == '.tex':
                conversion_type = "tex_to_docx"
            elif file_ext == '.pdf':
                conversion_type = "pdf_to_tex"
        
        if conversion_type and conversion_type in handlers:
            await handlers[conversion_type](update, doc)
        elif doc.mime_type.startswith("text"):
            await process_text_file(update, doc)
        else:
            raise ValueError("‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞! –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏.")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞: {str(e)}")
        await update.message.reply_text(f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {str(e)}")
    finally:
        context.user_data.pop('conversion', None)

async def process_pdf_to_tex(update: Update, doc):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é PDF –≤ LaTeX"""
    with tempfile.TemporaryDirectory() as tmp_dir:
        try:
            # –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
            file = await doc.get_file()
            content = await file.download_as_bytearray()
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ PDF
            pdf_path = os.path.join(tmp_dir, "input.pdf")
            with open(pdf_path, 'wb') as f:
                f.write(content)
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ LaTeX
            tex_path = os.path.join(tmp_dir, "output.tex")
            success = pdf_to_latex(pdf_path, tex_path)
            
            if not success:
                raise RuntimeError("–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ PDF –≤ LaTeX")
            
            # –£–ª—É—á—à–µ–Ω–∏–µ TeX —Ñ–∞–π–ª–∞
            enhance_tex_file(tex_path)
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –∞—Ä—Ö–∏–≤–∞
            zip_path = os.path.join(tmp_dir, "converted.zip")
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                zipf.write(tex_path, os.path.basename(tex_path))
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            with open(zip_path, 'rb') as f:
                await update.message.reply_document(
                    document=InputFile(f, filename=f"converted_{doc.file_name.replace('.pdf', '.zip')}"),
                    caption="‚úÖ PDF -> LaTeX –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\nüì¶ –ê—Ä—Ö–∏–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç .tex —Ñ–∞–π–ª."
                )
        except Exception as e:
            logger.error(f"PDF->TeX –æ—à–∏–±–∫–∞: {str(e)}")
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏: {str(e)}")

async def process_tex_to_pdf(update: Update, doc):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–ø–∏–ª—è—Ü–∏—é LaTeX –≤ PDF —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –ø—É—Ç–µ–π"""
    with tempfile.TemporaryDirectory() as tmp_dir:
        try:
            # –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
            file = await doc.get_file()
            content = await file.download_as_bytearray()
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ TeX
            tex_path = os.path.join(tmp_dir, "input.tex")
            with open(tex_path, 'wb') as f:
                f.write(content)
            
            # –î–ª—è Windows: –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –∫–æ—Ä–æ—Ç–∫–∏–π –ø—É—Ç—å
            if sys.platform == 'win32':
                try:
                    tex_path = win32api.GetShortPathName(tex_path)
                    logger.info(f"Using short path for LaTeX: {tex_path}")
                except Exception as e:
                    logger.warning(f"Short path conversion failed: {str(e)}")
            
            # –ö–æ–º–ø–∏–ª—è—Ü–∏—è –≤ PDF
            pdf_path = os.path.join(tmp_dir, "output.pdf")
            success = latex_to_pdf(tex_path, pdf_path)
            
            if not success:
                raise RuntimeError("–û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ LaTeX –≤ PDF")
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ PDF
            with open(pdf_path, 'rb') as f:
                await update.message.reply_document(
                    document=InputFile(f, filename=f"compiled_{doc.file_name.replace('.tex', '.pdf')}"),
                    caption="‚úÖ LaTeX -> PDF –∫–æ–º–ø–∏–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!"
                )
        except Exception as e:
            logger.error(f"TeX->PDF –æ—à–∏–±–∫–∞: {str(e)}")
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: {str(e)}")

async def process_tex_to_docx(update: Update, doc):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é LaTeX –≤ DOCX"""
    with tempfile.TemporaryDirectory() as tmp_dir:
        try:
            # –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
            file = await doc.get_file()
            content = await file.download_as_bytearray()
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ TeX
            tex_path = os.path.join(tmp_dir, "input.tex")
            with open(tex_path, 'wb') as f:
                f.write(content)
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ DOCX
            docx_path = os.path.join(tmp_dir, "output.docx")
            await convert_file(tex_path, docx_path, 'docx',
                             ['--standalone', '--resource-path=.', '--citeproc'])
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            with open(docx_path, 'rb') as f:
                await update.message.reply_document(
                    document=InputFile(f, filename=f"converted_{doc.file_name.replace('.tex', '.docx')}"),
                    caption="‚úÖ LaTeX -> DOCX –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!"
                )
        except Exception as e:
            logger.error(f"TeX->DOCX –æ—à–∏–±–∫–∞: {str(e)}")
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏: {str(e)}")

async def process_docx_to_tex(update: Update, doc):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é DOCX –≤ LaTeX"""
    with tempfile.TemporaryDirectory() as tmp_dir:
        try:
            # –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
            file = await doc.get_file()
            content = await file.download_as_bytearray()
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ DOCX
            docx_path = os.path.join(tmp_dir, "input.docx")
            with open(docx_path, 'wb') as f:
                f.write(content)
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ TeX
            tex_path = os.path.join(tmp_dir, "output.tex")
            await convert_file(docx_path, tex_path, 'latex')
            
            # –£–ª—É—á—à–µ–Ω–∏–µ TeX —Ñ–∞–π–ª–∞
            enhance_tex_file(tex_path)
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –∞—Ä—Ö–∏–≤–∞
            zip_path = os.path.join(tmp_dir, "converted.zip")
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                zipf.write(tex_path, os.path.basename(tex_path))
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            with open(zip_path, 'rb') as f:
                await update.message.reply_document(
                    document=InputFile(f, filename=f"converted_{doc.file_name.replace('.docx', '.zip')}"),
                    caption="‚úÖ DOCX -> LaTeX –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\nüì¶ –ê—Ä—Ö–∏–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç .tex —Ñ–∞–π–ª —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º —à–∞–±–ª–æ–Ω–æ–º."
                )
        except Exception as e:
            logger.error(f"DOCX->TeX –æ—à–∏–±–∫–∞: {str(e)}")
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏: {str(e)}")

async def process_text_file(update: Update, doc):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã"""
    tmp_path = None
    try:
        # –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
        file = await doc.get_file()
        content = await file.download_as_bytearray()
        text = content.decode('utf-8').replace(".", "-")
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
        with tempfile.NamedTemporaryFile(suffix=".txt", delete=False) as tmp:
            tmp.write(text.encode('utf-8'))
            tmp_path = tmp.name
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        with open(tmp_path, 'rb') as f:
            await update.message.reply_document(
                document=InputFile(f, filename=f"fixed_{doc.file_name}"),
                caption="‚úÖ –¢–µ–∫—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω: —Ç–æ—á–∫–∏ –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ —Ç–∏—Ä–µ!"
            )
    except Exception as e:
        logger.error(f"Text processing error: {str(e)}")
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {str(e)}")
    finally:
        if tmp_path and os.path.exists(tmp_path):
            os.remove(tmp_path)

def enhance_tex_file(file_path: str):
    """–î–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–µ–∞–º–±—É–ª—É –≤ TeX —Ñ–∞–π–ª (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    preamble = r"""\documentclass[12pt, a4paper]{article}
\usepackage[a4paper, left=15mm, right=15mm, top=20mm, bottom=20mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\begin{document}"""

    with open(file_path, 'r+', encoding='utf-8') as f:
        content = f.read()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ª–∏ —É–∂–µ –ø—Ä–µ–∞–º–±—É–ª–∞
        if r"\begin{document}" not in content:
            f.seek(0)
            f.write(preamble + "\n" + content + "\n\\end{document}")
            f.truncate()

async def convert_file(input_path: str, output_path: str, fmt: str, args=None):
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è pypandoc"""
    try:
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(
            None,
            lambda: pypandoc.convert_file(
                input_path, fmt,
                outputfile=output_path,
                extra_args=args or []
            )
        )
    except RuntimeError as e:
        logger.error(f"Pandoc error: {str(e)}")
        raise

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –±–æ—Ç–∞"""
    logger.error("–û—à–∏–±–∫–∞:", exc_info=context.error)
    if update:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞"
        )

def main():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è Windows
    if sys.platform == 'win32':
        try:
            import win32api
            logger.info("win32api available for path conversion")
        except ImportError:
            logger.warning("pywin32 not installed! Install with: pip install pywin32")
    
    application = Application.builder().token(TOKEN).build()

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    handlers = [
        CommandHandler('start', start),
        CommandHandler('help', help_command),
        CallbackQueryHandler(button_handler),
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text),
        MessageHandler(filters.Document.ALL, handle_document)
    ]
    
    application.add_handlers(handlers)
    application.add_error_handler(error_handler)

    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    application.run_polling()

if __name__ == '__main__':
    main()
